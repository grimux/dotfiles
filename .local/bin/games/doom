#!/usr/bin/env bash
#
# doom
#
### Description ############################################################################################
# Script for launching doom and the vairous mods I play.  GZDoom is very specific with how it handles mods
# and saves.  A consistent mod profile is needed when playing on the same savegames, so I created this
# script to automate that based on mod profiles.
############################################################################################################

### TODO ####################################################################
# - Finish implementing config parsing
# - Implement a modifiers system, i.e. ColourfulDoom etc.
#############################################################################

### Script Fail Events ###
# e - script stops on error
# u - error if undefined variable
# o pipefail - script fails if command piped fails
# x - output each line (debug)
#
#set -euox pipefail
set -euo pipefail

####################
### Global Flags ###
####################
# Use dmenu to choose mod.
use_dmenu=0
use_zenity=0
use_steam=0


##############
### Config ###
##############
gzdoom_ini_file="$HOME/.config/gzdoom/gzdoom.ini"
doomdir="$HOME/Games/gzdoom"
modsdir="$doomdir/mods"
mapsdir="$modsdir/map_packs"
addonsdir="$modsdir/addons"
savedir="$doomdir/save"


####################
### Mod Profiles ###
####################
# This file contains the mod profiles, inside a case statement.
# This makes it convienent to keep the profiles and launcher script separate.
mod_profiles="$HOME/.config/gzdoom/mod_profiles.sh"
source $mod_profiles


#######################
### Data and Arrays ###
#######################
### Listing of all the mod groupings. ###
# This greps out the formated mod names in the ini file, then puts them into an array.
# Formatting '[' and ']' are removed using sed.  This displays a nice clean name.
#mods_list=($(grep '\[.*\]' $ini_file | sed -e 's/\[//' -e 's/\]//'))

# Map Packs
map_pack_list=($mapsdir/*)

# Modifiers list
modifiers_list=(
	""
)


#################
### Functions ###
#################
# Help Section
function help_section() {
	echo "A script to launch Doom and its various mods."
	echo
	echo "Syntax: $(basename "$0") [-h|d|z|l|s] [mod name]"
	echo "options:"
	echo "h     Print this help screen."
	echo "d     Choose mod in dmenu."
	echo "z     Choose mod in zenity."
	echo "l     List installed mods."
	echo "s     Use Steam."
	echo
}

# Get arguments
function get_arguments() {
	while getopts ":hldsz" option; do
		case $option in
			d) echo "Using dmenu."; use_dmenu=1;;

			h) help_section; exit;;

			l) list_mods; exit;;

			s) echo "Using Steam."; use_steam=1;;

			z) echo "Using zenity."; use_zenity=1;;

			\?) echo "Error: Invalid option"; exit;;

		esac
	done
}

# List the mods
function list_mods() {
	# Simply print the array $mods_list
	printf "%s\n" "${mod_list_array[@]}"
}

# Dmenu
function choose_in_dmenu() {
	# Local variable to store the mod choice in.
	local dmenu_choice
	local prompt="Doom mod: "
	local mod_array=$(list_mods)

	# Mod choice variable is equal to the selection from dmenu.
	dmenu_choice=$(printf '%s\n' "${mod_array[@]}" | dmenu -i -l 20 -p "$prompt")

	# Return the choice
	echo "$dmenu_choice"
}

# Choose the mod using zenity.
function choose_in_zenity() {
	# Local variable to store the mod choice in.
	local zenity_choice
	local prompt="Doom mod:"
	local mod_array=$(list_mods)

	# Mod choice variable is equal to the selection from zenity.
	zenity_choice=$(printf '%s\n' "${mod_array[@]}" | zenity --title=DoomMod --width 400 --height 600 --list --column "$prompt")

	# Return the choice
	echo "$zenity_choice"
}

# Launch doom
function launch_doom() {
	# Local functions to store the arguments passed to the function.
	# This helps with organization.
	local iwad="$1"
	local wads="$2"
	local savedir="$3"
	local map="$4"
	local cheats="$5"
	local skill="$6"
	local program_to_use="gzdoom"
	local steam_id

	# Set the steam id for the corresponding game, Doom 1 or Doom 2.
	# doom1: 2280
	# doom2: 2300
	case $iwad in
		"DOOM.WAD") steam_id=2280;;
		"DOOM2.WAD") steam_id=2300;;
		"") echo "iwad is empty string"; exit 1;;
		*) echo "Unrecognized iwad name"; exit 1;;
	esac

	# Check to see if Steam should be used.
	if [ $use_steam -eq 1 ]; then
		program_to_use="steam -applaunch $steam_id"
	# If not, launch gzdoom directly.
	else
		program_to_use="gzdoom"
	fi

	$program_to_use \
		-iwad $iwad \
		-file $wads \
		-savedir $savedir \
		$map \
		$cheats \
		$skill
}

# Check if the mod exists within the array.
function check_mods() {
	# First argument is the user's input, which mod to select.
	local mod_to_check="$1"

	# Local variables
	local title
	local does_it_exist

	# Loop through the mod_list_array and check if the mod is there.
	for title in ${mod_list_array[@]}; do
		# If there is a match, set does_it_exist to 1 and stop.
		if [ "$mod_to_check" == "$title" ]; then
			does_it_exist=1
			break
		# Otherwise, set the flag to 0.
		else
			does_it_exist=0
		fi
	done

	# Return 1 if the title exists, 0 if not
	echo "$does_it_exist"
}

# Function to remove the first line of the gzdoom.ini file.  The first line is generated at startup and
# contains the date and time.  This is annoying to deal with when tracking with git.  So this will remove
# the line after creation.
function fix_ini_for_git() {
	# -n +2 : start at line 2 of the file.
	echo "$(tail -n +2 "$gzdoom_ini_file")" > "$gzdoom_ini_file"
}

# Function to fix the caps lock returning to normal after using gzdoom.
function fix_caps_lock() {
	setxkbmap -option caps:escape
}


###############
### Parsing ###
###############
#
# This section is for functions that I am experimenting with in parsing text files.  These are currently only
# being used with the testing function down belown.  Be sure to disable main function when using these.

# Check ini for matching mod name
function check_mods_parse() {
	# Mod name, passed as argument.
	local mod_name="$1"

	# Exists flag
	local exists

	# Grep the ini file to search for a match
	# Grep will return 1 if no matches were found
	# Also send grep's output to null
	#grep "\[$mod_name\]" $ini_file > /dev/null

	# If the grep returns 0, then the mod name exists within the ini
	#[[ $(grep "\[$mod_name\]" $ini_file > /dev/null) -eq 0 ]] && exists=1

	# Return flag value
	# 1 exists, 0 does not exist
	echo $exists
}

function make_mod_array() {
	# Name of doom mod, passed as an argument to the function
	mod_name="$1"

	# Array for the chosen mod.  Will have all the config options
	# such as wads, iwads, maps, skill, etc
	mod_array=$(awk "/\[$mod_name\]/,/;;/" $ini_file)

	# Read the variable $mod_array into and array delimited by \n
	#readarray -t mod_array <<< ${mod_array}
}

function parse_ini_to_array() {
	local ini_file key mod_array raw_mod_data

	# First argument is the file to parse.
	ini_file="$1"

	# Second argument is the keyword to search for in the file.
	key="$2"

	# Array for the mod and its settings.
	mapfile mod_array < <(awk "/\[$key\]/,/;;/" $ini_file)

	raw_mod_data="${mod_array[@]/[[:alpha:]]*=/}"

	printf "%s\n" "${#raw_mod_data[@]}"
}

############
### Main ###
############
#
# Main is a working script.  Any testing should be done in the testing function.
# Leave this as a complete and working script.
#
main() {
	# Local variables.
	local does_mod_exist
	local chosen_mod


	## Get arguments ##
	##---------------##
	# Get flag options passed to the script.
	get_arguments "$@"

	# If there were any options passed to the script, remove them.
	if [ $# -gt 1 ]; then
		# First, remove the leading arguments, "-s".
		shift $(( OPTIND - 1 ))
	fi

	## Main Logic ##
	##------------##
	# Check to see if we are using dmenu or not.
	if [ "$use_dmenu" -eq 1 ]; then
		# If so, set chosen mod to the output of choose_in_dmenu function.
		chosen_mod=$(choose_in_dmenu)

	# Use zenity to set the chosen mod.
	elif [ "$use_zenity" -eq 1 ]; then
		chosen_mod=$(choose_in_zenity)

	# Else if there are no arguments.
	elif [ -z "$@" ]; then
		echo "Please choose a mod profile:"
		echo
		list_mods
		exit

	# Base case when an argument is supplied.  Expects mod name.
	else
		chosen_mod="$@"
	fi


	## Does mod exist? ##
	##-----------------##
	# Check if the mod exists within the mod_list_array.
	# Returns 1 if it exists, 0 if not.
	does_mod_exist=$(check_mods "$chosen_mod")

	# If the mod does not exist, tell us and exit with error.
	if [ "$does_mod_exist" -eq 0 ]; then
		echo "That mod is not in the array."
		exit 1
	fi


	## Source .config/gzdoom/mod_profiles.sh ##
	##---------------------------------------##
	# Call mod_profiles, sourced from mod_profiles
	mod_profiles "$chosen_mod"


	## Launch gzdoom, with or without Steam. ##
	##---------------------------------------##
	# Call to launch doom with all the parameters
	launch_doom "$iwad" "$wads" "$savedir" "$maps" "$cheats" "$skill"


	## Fix gzdoom.ini ##
	##----------------##
	# Prepare the gzdoom ini file for git.
	# Basically, this removes the date header of the file.  This gets generated every time
	# gzdoom is launched.  Very annoying to track with git, this will remove that date.
	fix_ini_for_git

	fix_caps_lock
}

###############
### Testing ###
###############
#
# This function is used to toggle functions that I am testing.  These will usually break things and
# can be unpredictible.  Be careful.
#
# Trying to parse config files using arrays.
testing_parse() {
	#make_mod_array "$1"
	#printf "%s\n" "${mod_array[@]}"
	#set_gzdoom_options


	chosen_mod_settings=($(parse_ini_to_array "$ini_file" "$1"))
	parse_ini_to_array "$ini_file" "$1"

	printf "%s\n" "${chosen_mod_settings[@]}"
}


###################
### Entry Point ###
###################
# Only choose one main function to run, "main" or "testing".
# Call to main, the working script.
main "$@"

# Call to the testing section.
#testing "$@"

############
### Exit ###
############
exit
